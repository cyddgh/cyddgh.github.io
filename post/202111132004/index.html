<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>使用腾讯云搭建Syncthing来同步obsidian | 软通达</title>
<link rel="shortcut icon" href="https://cyddgh.github.io/favicon.ico?v=1758499638087">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cyddgh.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="使用腾讯云搭建Syncthing来同步obsidian | 软通达 - Atom Feed" href="https://cyddgh.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="预警：本文所提及操作属于高阶内容，涉及服务器配置、docker技术、网络安全等等内容。我本人也不是很了解，只勉强达到“会用”的程度，对过程的表述和理解可能有偏差，仅提供一种同步的思路。本文涉及到购买建议，请三思后行。本文仅代表我个人通过相关..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://cyddgh.github.io">
  <img class="avatar" src="https://cyddgh.github.io/images/avatar.png?v=1758499638087" alt="">
  </a>
  <h1 class="site-title">
    软通达
  </h1>
  <p class="site-description">
    软件改善生活。本网站会讨论知识管理、时间管理、知识卡片、卡片写作等主题，软件包括thebrain、tiddlywiki、RoamResearch、Obsidian等等。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              使用腾讯云搭建Syncthing来同步obsidian
            </h2>
            <div class="post-info">
              <span>
                2021-11-13
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>预警：本文所提及操作属于高阶内容，涉及服务器配置、docker技术、网络安全等等内容。我本人也不是很了解，只勉强达到“会用”的程度，对过程的表述和理解可能有偏差，仅提供一种同步的思路。本文涉及到购买建议，请三思后行。本文仅代表我个人通过相关步骤，实现了使用腾讯云搭建Syncthing来同步obsidian的效果，不代表在任何情况（例如内网等）都能实现，不代表数据能足够安全等等，本人对因本文造成的损失概不负责。</p>
<h1 id="背景介绍">背景介绍</h1>
<p>obsidian早鸟价已经结束，同步服务的价格恢复到10美元（按月付）/8美元（按年付），超出了很多ob使用者的预期。在此背景下，使用者开始寻求一些ob第三方同步的方法，我这里也简单归纳一下：</p>
<ul>
<li>坚果云：如果只是Win、MAC之间的同步，推荐使用。不推荐与[[FolderSync（同步软件）]]连用给手机端做同步，很多人都遇到问题，可能是因为坚果云对第三方API调用的限制。</li>
<li>icloud：如果你的设备设计iOS（iPhone或iPAD），这是推荐的第三方同步方法，另一种能同步iOS的方法是[[Working copy]]，但难度很高，我没有尝试过，听说效果也不是很好。</li>
<li>OneDrive：似乎可以和[[FolderSync（同步软件）]]连用给手机端同步，这可能要问Bon。但可能要考虑onedrive的网络问题和权限问题。我也不推荐该方法。</li>
<li>Syncthing：一个开源的同步软件，本文主要使用的软件，也是[[shaosen]]、[[淳帅二代]]主推的软件，我本人也推荐使用此第三方软件，但对该软件的配置问题不是很懂（有问题请不要问我，我也不太清楚），大家可以去github上留言： https://github.com/syncthing/syncthing 。这软件现在已经有41.4K的加星（star）这是很惊人的数量，说明软件深得人心。</li>
</ul>
<p>使用Syncthing同步有一个问题是，必须有一个设备保持24小时在线，才能保证数据一直是最新的（其实所有的同步都是这样，需要有一个服务24小时运行）。因此我想到要租一个服务器（24小时在线且联网的电脑）。我先咨询了腾讯云的云开发CloudBase，想要使用其来搭建Syncthing服务。但工程师说，云开发的机器只能搭配已经适配好的那几款软件，即使有一个github导入，也必须是导入那几个适配好的软件。因此，我认为的最简单的也是最便宜的方案无法成功。</p>
<p>但我也给内部人员提出了相应建议，希望能早日适配syncthing。<br>
<img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113202457.png" alt="" loading="lazy"></p>
<h1 id="正文部分">正文部分</h1>
<h2 id="购买服务器">购买服务器</h2>
<p>今天刚好见到了双十一腾讯云在促销自家的服务器（这活动一年有几次，所以如果你不是在最近看到，可以等等优惠的价格），可以点击我的推广链接（ https://cloud.tencent.com/act/double11?spread_hash_key=7f140183941722f69697fc0aeb325df9  ）前往会场。在“爆品秒杀”一栏，可以找到一台2核4G的服务器，3年只要198（我买的是这个），下面其实还有一台1核2G的3年144，但不知道性能可不可以，但更便宜。如果在购买和使用中遇到问题，请联系腾讯云的工程师和售后人员，他们应该很乐意也有义务提供专业的协助。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113203001.png" alt="" loading="lazy"></figure>
<p>点击购买后，镜像一栏选择docker，我无法截图了，因为这价格一人只能买一次。选错镜像也没关系，之后可以重置镜像，服务器不要选错就行。</p>
<h2 id="宝塔面板的配置">宝塔面板的配置</h2>
<p>购买后，到轻量应用服务器页面（ https://console.cloud.tencent.com/lighthouse ），上面的帮助文档可以选择“宝塔面板”的方便入门，点击“安装和配置宝塔 Linux 面板腾讯云专享版”（ https://cloud.tencent.com/document/product/1207/54078 ）先查看宝塔面板的配置文档，直接从文中“配置轻量应用服务器网络防火墙”一节开始看，安装文中的步骤操作。<br>
<img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113203811.png" alt="" loading="lazy"></p>
<p>点击“更多”-“管理”。<br>
<img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113204032.png" alt="" loading="lazy"></p>
<p>再点击“防火墙”-“添加规则”-创建两个规则，一个端口号是<code>8888</code>一个是<code>8384</code>（8888是宝塔的端口，8384是后面给syncthing预留的登陆端口），备注可不填写，其他选项不动。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113204214.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113204347.png" alt="" loading="lazy"></figure>
<p>之后的内容请根据“安装和配置宝塔 Linux 面板腾讯云专享版”（ https://cloud.tencent.com/document/product/1207/54078 ）的“配置宝塔 Linux 面板”操作。</p>
<h2 id="登陆宝塔界面">登陆宝塔界面</h2>
<p>配置好宝塔面板后，在浏览器输入<code>http://你的公网IP地址:8888/tencentcloud</code>，具体见“应用管理”一栏。</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113205144.png" alt="" loading="lazy"></figure>
<h2 id="安装docker">安装docker</h2>
<p>点击宝塔页面左边的“软件商店”-检索“docker”-选择安装“Docker管理器 3.7”。<br>
<img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113205304.png" alt="" loading="lazy"></p>
<p>然后就会自动安装，等待安装结束。</p>
<p>参考“安装 Docker 并配置镜像加速源”（ https://cloud.tencent.com/document/product/1207/45596 ）一文，配置docker加速镜像。</p>
<p>但我是直接在桌面新建一个txt文件，输入以下代码，重命名为<code>daemon.json</code>，通过宝塔面包的“文件”，找到<code>/etc/docker/</code>这个地址，然后再将<code>daemon.json</code>上传。</p>
<pre><code>{
&quot;registry-mirrors&quot;: [
 &quot;https://mirror.ccs.tencentyun.com&quot;
]
}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113205903.png" alt="" loading="lazy"></figure>
<h2 id="通过docker安装syncthing">通过docker安装Syncthing</h2>
<p>在服务器的界面（ https://console.cloud.tencent.com/lighthouse/ ）点击“登录”，进入到你服务器中开始输入代码（此步骤不唯一，但应该对新手最简单）。</p>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113210241.png" alt="" loading="lazy"></figure>
<p>之后会弹出一个黑色界面（类似命令提示符CMD），让你输入代码。</p>
<p>Docker的入门教程可以参考菜鸟出品的 https://www.runoob.com/docker/docker-hello-world.html  。</p>
<p>但我用不了那么多，我参考了“docker安装Syncthing，并配置数据同步备份” （ https://www.tqwba.com/x_d/jishu/190444.html ），这篇与CSDN上一篇很像（ https://blog.csdn.net/weixin_44395100/article/details/108233403 ），但CSDN无法复制代码，我就选择了前者。</p>
<p>首先，先输入<code>sudo docker</code>来验证docker是否安装成功，如果下面出现下面的界面就是成功的（没有报错，然后出来了一堆文字）。这样就可以开始按照上文来安装syncthing。<br>
<img src="https://gitee.com/cyddgi/picture-store/raw/master/img/20211113210835.png" alt="" loading="lazy"></p>
<p>根据上文的代码，并在前面加上<code>sudo</code>，以获取最高权限，否则在该用户无法安装。即输入下面的代码：<br>
<code>sudo docker run -d -p 8384:8384 -p 22000:22000 -v /users/syncthing:/var/syncthing syncthing/syncthing</code></p>
<p>等待安装结束，文中的8384，就是之前在防火墙添加的8384，如果此处修改，防火墙那里的设置也要修改。</p>
<p>在你的浏览器中输入<code>http://你的公网IP地址:8384</code>，进入syncthing。之后就按正常操作配置syncthing，这已经有很多人论述，不在本文介绍范围内。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D">背景介绍</a></li>
<li><a href="#%E6%AD%A3%E6%96%87%E9%83%A8%E5%88%86">正文部分</a>
<ul>
<li><a href="#%E8%B4%AD%E4%B9%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">购买服务器</a></li>
<li><a href="#%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E7%9A%84%E9%85%8D%E7%BD%AE">宝塔面板的配置</a></li>
<li><a href="#%E7%99%BB%E9%99%86%E5%AE%9D%E5%A1%94%E7%95%8C%E9%9D%A2">登陆宝塔界面</a></li>
<li><a href="#%E5%AE%89%E8%A3%85docker">安装docker</a></li>
<li><a href="#%E9%80%9A%E8%BF%87docker%E5%AE%89%E8%A3%85syncthing">通过docker安装Syncthing</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://cyddgh.github.io/post/202111022053/">
              <h3 class="post-title">
                简易自定义OB主题（Style settings插件介绍）
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '2b651bfa82376af59b3e',
    clientSecret: 'dde60ece1554a451376e1c444a5f39cd60b06ed4',
    repo: 'cyddgh.github.io',
    owner: 'cyddgh',
    admin: ['cyddgh'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://cyddgh.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
